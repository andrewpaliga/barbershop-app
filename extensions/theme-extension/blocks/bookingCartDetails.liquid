{% assign section_title = block.settings.section_title %}
{% assign show_only_with_bookings = block.settings.show_only_with_bookings %}
{% assign show_date_time = block.settings.show_date_time %}
{% assign show_staff = block.settings.show_staff %}
{% assign show_location = block.settings.show_location %}
{% assign show_notes = block.settings.show_notes %}
{% assign date_format = block.settings.date_format %}
{% assign time_format = block.settings.time_format %}
{% assign no_bookings_message = block.settings.no_bookings_message %}

<!-- Load the Gadget API client library asynchronously -->
<!-- The defer attribute ensures the script loads after HTML parsing but before DOMContentLoaded -->
<script defer src="https://barbershop--development.gadget.app/api/client/web.min.js"></script>

<style>
  /* Hide the main container since we're injecting into existing cart items */
  .booking-cart-details {
    display: none !important;
  }
  
  /* Hide Shopify's default property display for technical metadata */
  .cart__item-properties,
  .cart-item__properties,
  .line-item__properties,
  [data-cart-item-properties] {
    display: none !important;
  }
  
  /* Hide specific technical properties by their labels */
  .cart__item-property,
  .cart-item__property,
  .line-item__property,
  [data-cart-item-property] {
    display: none !important;
  }
  
  /* Hide specific technical metadata properties by their content */
  .cart__item-property:has(dt:contains("Service ID")),
  .cart__item-property:has(dt:contains("Variant ID")),
  .cart__item-property:has(dt:contains("Staff ID")),
  .cart__item-property:has(dt:contains("Location ID")),
  .cart__item-property:has(dt:contains("Scheduled At")),
  .cart__item-property:has(dt:contains("Location")),
  .cart__item-property:has(dt:contains("Duration")) {
    display: none !important;
  }
  
  /* Alternative approach: Hide properties containing technical metadata */
  .cart__item-property dt:contains("Service ID"),
  .cart__item-property dt:contains("Variant ID"),
  .cart__item-property dt:contains("Staff ID"),
  .cart__item-property dt:contains("Location ID"),
  .cart__item-property dt:contains("Scheduled At"),
  .cart__item-property dt:contains("Location"),
  .cart__item-property dt:contains("Duration") {
    display: none !important;
  }
  
  /* Hide technical metadata properties by targeting their text content */
  .cart__item-property:has(dt:contains("Service ID")),
  .cart__item-property:has(dt:contains("Variant ID")),
  .cart__item-property:has(dt:contains("Staff ID")),
  .cart__item-property:has(dt:contains("Location ID")),
  .cart__item-property:has(dt:contains("Scheduled At")),
  .cart__item-property:has(dt:contains("Location")),
  .cart__item-property:has(dt:contains("Duration")) {
    display: none !important;
  }
  
  /* Show only our injected booking details */
  .injected-booking-details {
    margin-top: 0.5rem;
    font-size: 1.1rem;
    color: rgb(var(--color-foreground-75, --color-foreground));
  }
  
  .injected-booking-detail {
    display: block;
    margin-bottom: 0.3rem;
    font-size: 1.1rem;
    line-height: 1.4;
  }
  
  .injected-booking-detail:last-child {
    margin-bottom: 0;
  }
  
  .injected-booking-detail__label {
    font-weight: var(--font-weight-medium, 500);
    color: rgb(var(--color-foreground));
    font-size: 1.1rem;
  }
  
  .injected-booking-detail__value {
    color: rgb(var(--color-foreground-75, --color-foreground));
    font-size: 1.1rem;
  }
  
  @media screen and (max-width: 749px) {
    .injected-booking-details {
      margin-top: 0.4rem;
      font-size: 1rem;
    }
    
    .injected-booking-detail {
      margin-bottom: 0.25rem;
      font-size: 1rem;
    }
    
    .injected-booking-detail__label,
    .injected-booking-detail__value {
      font-size: 1rem;
    }
  }
</style>

<div class="booking-cart-details" id="booking-cart-details" style="display: none;">
  <!-- Hidden container - we inject booking details directly into cart items -->
</div>

<script>
  window.formatBookingDateTime = function(date, time, shopTimezone) {
    try {
      // Parse the date and time
      const bookingDate = new Date(date);
      
      // Format date
      const dateFormatString = "{{ date_format }}";
      let formattedDate = bookingDate.toLocaleDateString('en-US', {
        year: 'numeric',
        month: 'long',
        day: 'numeric'
      });
      
      // Format time
      let formattedTime = time;
      if (time && time.includes(':')) {
        const [hours, minutes] = time.split(':');
        const timeObj = new Date();
        timeObj.setHours(parseInt(hours), parseInt(minutes));
        
        const timeFormatString = "{{ time_format }}";
        if (timeFormatString.includes('%I')) {
          // 12-hour format
          formattedTime = timeObj.toLocaleTimeString('en-US', {
            hour: 'numeric',
            minute: '2-digit',
            hour12: true
          });
        } else {
          // 24-hour format
          formattedTime = timeObj.toLocaleTimeString('en-US', {
            hour: '2-digit',
            minute: '2-digit',
            hour12: false
          });
        }
      }
      
      return {
        formattedDate,
        formattedTime
      };
    } catch (error) {
      console.error('Error formatting date/time:', error);
      return {
        formattedDate: date,
        formattedTime: time
      };
    }
  };

  // Helper function to find cart line items in the DOM
  function findCartLineItems() {
    // Common Shopify cart line item selectors
    const selectors = [
      '.cart__item',
      '.cart-item', 
      '.line-item',
      '[data-line-item]',
      'tr[data-variant-id]',
      '.cart-item-row',
      '.cart__line',
      '.cart-line-item'
    ];
    
    for (const selector of selectors) {
      const items = document.querySelectorAll(selector);
      if (items.length > 0) {
        return items;
      }
    }
    
    return [];
  }
  
  // Helper function to find the product info container within a line item
  function findProductInfoContainer(lineItem) {
    // Common selectors for product info areas
    const selectors = [
      '.cart-item__details',
      '.cart-item__info',
      '.product-info',
      '.product-details',
      '.cart-item__name',
      '.line-item__name',
      '.item-details',
      '.product-title'
    ];
    
    for (const selector of selectors) {
      const container = lineItem.querySelector(selector);
      if (container) {
        return container;
      }
    }
    
    // If no specific container found, return the line item itself
    return lineItem;
  }
  
  // Helper function to find the best insertion point within product info
  function findInsertionPoint(productInfoContainer) {
    // Look for variant info, price, or other product details to insert after
    const selectors = [
      '.variant-title',
      '.product-variant',
      '.cart-item__variant',
      '.product-price',
      '.cart-item__price',
      '.product-title',
      'h3',
      'h4'
    ];
    
    for (const selector of selectors) {
      const element = productInfoContainer.querySelector(selector);
      if (element) {
        return element;
      }
    }
    
    // If no specific element found, insert at the end of the container
    return productInfoContainer.lastElementChild || productInfoContainer;
  }
  
  // Helper function to match cart line items with booking data
  function matchLineItemWithBooking(lineItem, bookingItem) {
    // Try to match by variant ID
    const variantId = lineItem.getAttribute('data-variant-id') || 
                     lineItem.querySelector('[data-variant-id]')?.getAttribute('data-variant-id');
    
    if (variantId && bookingItem.variant_id.toString() === variantId) {
      return true;
    }
    
    // Try to match by product title
    const productTitle = lineItem.querySelector('.cart-item__name, .line-item__name, .product-title, h3, h4')?.textContent?.trim();
    if (productTitle && productTitle.includes(bookingItem.product_title)) {
      return true;
    }
    
    return false;
  }
  
  // Function to hide unwanted technical metadata properties
  console.log('📝 Function hideTechnicalMetadataProperties defined');
  
  function hideTechnicalMetadataProperties() {
    const unwantedProperties = [
      'Service ID', 'Variant ID', 'Staff ID', 'Location ID', 
      'Scheduled At', 'Location', 'Duration'
    ];
    
    console.log('🔍 Attempting to hide technical metadata...');
    
    // More comprehensive selectors for different theme variations
    const allSelectors = [
      '.cart__item-property', '.cart-item__property', '.line-item__property', 
      '[data-cart-item-property]', '.property', '.properties',
      '.cart__item-properties', '.cart-item__properties', '.line-item__properties',
      '[data-cart-item-properties]', '.cart-item__details .property',
      '.cart__item-details .property', '.line-item__details .property'
    ];
    
    let totalHidden = 0;
    
    allSelectors.forEach(selector => {
      const elements = document.querySelectorAll(selector);
      console.log(`🔍 Found ${elements.length} elements with selector: ${selector}`);
      
      elements.forEach(element => {
        // Check if this element contains unwanted text
        const hasUnwantedText = unwantedProperties.some(unwanted => 
          element.textContent.includes(unwanted)
        );
        
        if (hasUnwantedText) {
          console.log(`🚫 Hiding element containing: ${element.textContent.trim().substring(0, 50)}...`);
          element.style.display = 'none';
          element.style.visibility = 'hidden';
          element.style.opacity = '0';
          totalHidden++;
        }
      });
    });
    
    // Also try to hide any text nodes containing unwanted content
    const walker = document.createTreeWalker(
      document.body,
      NodeFilter.SHOW_TEXT,
      null,
      false
    );
    
    let textNode;
    while (textNode = walker.nextNode()) {
      const hasUnwantedText = unwantedProperties.some(unwanted => 
        textNode.textContent.includes(unwanted)
      );
      
      if (hasUnwantedText) {
        const parent = textNode.parentElement;
        if (parent && !parent.classList.contains('injected-booking-details')) {
          console.log(`🚫 Hiding parent element containing: ${textNode.textContent.trim().substring(0, 50)}...`);
          parent.style.display = 'none';
          totalHidden++;
        }
      }
    }
    
    console.log(`✅ Total elements hidden: ${totalHidden}`);
    
    // If nothing was hidden, try a more aggressive approach
    if (totalHidden === 0) {
      console.log('⚠️ No elements hidden, trying aggressive approach...');
      
      // Hide any element containing the unwanted text
      const allElements = document.querySelectorAll('*');
      allElements.forEach(element => {
        if (element.children.length === 0 && element.textContent) {
          const hasUnwantedText = unwantedProperties.some(unwanted => 
            element.textContent.includes(unwanted)
          );
          
          if (hasUnwantedText) {
            const parent = element.closest('div, span, p, td, li');
            if (parent && !parent.classList.contains('injected-booking-details')) {
              parent.style.display = 'none';
              totalHidden++;
            }
          }
        }
      });
      
      console.log(`✅ Aggressive approach hidden: ${totalHidden} elements`);
    }
  }

  // Wait for the HTML document to be fully loaded and parsed
  document.addEventListener('DOMContentLoaded', async () => {
    console.log('🚀 Cart extension loaded!');
    console.log('⚙️ Extension settings:', {
      showDateTime: {{ show_date_time | json }},
      showStaff: {{ show_staff | json }},
      showLocation: {{ show_location | json }},
      showNotes: {{ show_notes | json }},
      hideTechnicalMetadata: {{ hide_technical_metadata | json }}
    });
    
    // Initialize the Gadget API client
    window.api = new BarbershopClient();
    
    const showDateTime = {{ show_date_time | json }};
    const showStaff = {{ show_staff | json }};
    const showLocation = {{ show_location | json }};
    const showNotes = {{ show_notes | json }};
    const hideTechnicalMetadata = {{ hide_technical_metadata | json }};
    
    try {
      // Get cart data from Shopify
      const response = await fetch('/cart.js');
      const cart = await response.json();
      
      const bookingItems = [];
      
      // Check each cart item for booking properties
      for (const item of cart.items) {
        const bookingData = {};
        let hasBookingData = false;
        
        // Look for booking properties in line item properties
        if (item.properties) {
          for (const [key, value] of Object.entries(item.properties)) {
            // Map our new property names to the display logic
            if (['Booking Date', 'Booking Time', 'Barber', 'Duration', 'Notes'].includes(key)) {
              hasBookingData = true;
              bookingData[key] = value;
            }
            // Also check for legacy property names for backward compatibility
            if (['staff_id', 'staffId', '_staff_id', 'location_id', 'locationId', '_location_id', 'booking_date', '_booking_date', 'booking_time', '_booking_time', 'booking_notes', '_booking_notes'].includes(key)) {
              hasBookingData = true;
              bookingData[key] = value;
            }
          }
        }
        
        if (hasBookingData) {
          bookingItems.push({
            ...item,
            bookingData
          });
        }
      }
      
      if (bookingItems.length === 0) {
        return; // No bookings to inject
      }
      
      // Find cart line items in the DOM
      const cartLineItems = findCartLineItems();
      
      if (cartLineItems.length === 0) {
        console.warn('No cart line items found in DOM');
        return;
      }
      
      // Inject booking details into matching line items
      for (const bookingItem of bookingItems) {
        for (const lineItem of cartLineItems) {
          if (matchLineItemWithBooking(lineItem, bookingItem)) {
            // Check if we already injected booking details
            if (lineItem.querySelector('.injected-booking-details')) {
              continue;
            }
            
            // Find the product info container and insertion point
            const productInfoContainer = findProductInfoContainer(lineItem);
            const insertionPoint = findInsertionPoint(productInfoContainer);
            
            // Build booking details HTML with compact inline styling
            let bookingDetailsHtml = '<div class="injected-booking-details">';
            
            // Show date and time
            if (showDateTime && (bookingItem.bookingData['Booking Date'] || bookingItem.bookingData['booking_date'] || bookingItem.bookingData._booking_date)) {
              const date = bookingItem.bookingData['Booking Date'] || bookingItem.bookingData['booking_date'] || bookingItem.bookingData._booking_date;
              const time = bookingItem.bookingData['Booking Time'] || bookingItem.bookingData['booking_time'] || bookingItem.bookingData._booking_time;
              
              if (date || time) {
                const formatted = window.formatBookingDateTime(date, time);
                bookingDetailsHtml += `<div class="injected-booking-detail">`;
                bookingDetailsHtml += `<span class="injected-booking-detail__label">Date & Time: </span>`;
                bookingDetailsHtml += `<span class="injected-booking-detail__value">${formatted.formattedDate} at ${formatted.formattedTime}</span>`;
                bookingDetailsHtml += `</div>`;
              }
            }
            
            // Show barber
            if (showStaff && bookingItem.bookingData['Barber']) {
              bookingDetailsHtml += `<div class="injected-booking-detail">`;
              bookingDetailsHtml += `<span class="injected-booking-detail__label">Barber: </span>`;
              bookingDetailsHtml += `<span class="injected-booking-detail__value">${bookingItem.bookingData['Barber']}</span>`;
              bookingDetailsHtml += `</div>`;
            }
            
            // Show duration
            if (showLocation && bookingItem.bookingData['Duration']) {
              bookingDetailsHtml += `<div class="injected-booking-detail">`;
              bookingDetailsHtml += `<span class="injected-booking-detail__label">Length: </span>`;
              bookingDetailsHtml += `<span class="injected-booking-detail__value">${bookingItem.bookingData['Duration']}</span>`;
              bookingDetailsHtml += `</div>`;
            }
            
            // Show notes
            if (showNotes && bookingItem.bookingData['Notes']) {
              const notes = bookingItem.bookingData['Notes'];
              if (notes && notes.trim()) {
                bookingDetailsHtml += `<div class="injected-booking-detail">`;
                bookingDetailsHtml += `<span class="injected-booking-detail__label">Notes: </span>`;
                bookingDetailsHtml += `<span class="injected-booking-detail__value">${notes}</span>`;
                bookingDetailsHtml += `</div>`;
              }
            }
            
            bookingDetailsHtml += '</div>';
            
            // Inject the booking details after the insertion point
            insertionPoint.insertAdjacentHTML('afterend', bookingDetailsHtml);
            break; // Found and injected, move to next booking item
          }
        }
      }
      
      // Hide unwanted technical metadata properties if setting is enabled
      if (hideTechnicalMetadata) {
        console.log('🔧 Setting enabled, calling hideTechnicalMetadataProperties()...');
        hideTechnicalMetadataProperties();
      } else {
        console.log('🔧 Setting disabled, skipping metadata hiding');
      }
      
    } catch (error) {
      console.error('Error injecting booking details:', error);
    }
  });
</script>

{% schema %}
{
  "name": "Cart Booking Info",
  "target": "section",
  "settings": [
    { "type": "text", "label": "Section Title", "id": "section_title", "default": "Your Booking Details" },
    {
      "type": "checkbox",
      "label": "Show section only when bookings exist",
      "id": "show_only_with_bookings",
      "default": true
    },
    { "type": "checkbox", "label": "Show date and time", "id": "show_date_time", "default": true },
    { "type": "checkbox", "label": "Show barber name", "id": "show_staff", "default": true },
    { "type": "checkbox", "label": "Show service duration", "id": "show_location", "default": true },
    { "type": "checkbox", "label": "Show booking notes", "id": "show_notes", "default": true },
    { "type": "checkbox", "label": "Hide technical metadata", "id": "hide_technical_metadata", "default": false, "info": "Hide Service ID, Variant ID, Staff ID, Location ID, Scheduled At, and other technical details from cart display" },
    { "type": "text", "label": "Date format", "id": "date_format", "default": "%B %d, %Y" },
    { "type": "text", "label": "Time format", "id": "time_format", "default": "%I:%M %p" },
    {
      "type": "textarea",
      "label": "No bookings message",
      "id": "no_bookings_message",
      "default": "No barber service bookings in your cart."
    }
  ]
}
{% endschema %}