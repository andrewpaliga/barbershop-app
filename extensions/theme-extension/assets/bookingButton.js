// Ensure API client is available
if (!window.api && window.BarbershopClient) {
  window.api = new BarbershopClient();
}

// Load app configuration (generated by scripts/generate-config.js)
let AppConfig = null;
try {
  if (typeof window !== 'undefined' && window.SimplyBookConfig) {
    AppConfig = window.SimplyBookConfig;
  }
} catch (e) {
  console.warn('SimplyBook: Could not load app configuration, using defaults');
}

// Global variables to store booking data and current selection
let bookingData = null;
let bookingDataPromise = null; // single-flight fetch cache
let currentSelection = {
  type: null,
  serviceId: null,
  staffId: null,
  variantId: null,
  selectedDate: null,
  selectedTime: null,
  locationId: null,
  serviceExplicitlyChosen: false
};
let currentWeekStart = null;

// Utility functions for UI manipulation
function setLoading(show) {
  const loadingElement = document.getElementById('booking-loading');
  const selectionElement = document.getElementById('booking-selection');
  const formElement = document.getElementById('booking-form-container');
  
  if (loadingElement) {
    loadingElement.style.display = show ? 'block' : 'none';
  }
  if (selectionElement) {
    selectionElement.style.display = show ? 'none' : (formElement && formElement.style.display !== 'none' ? 'none' : 'block');
  }
  if (formElement) {
    formElement.style.display = show ? 'none' : 'none';
  }
}

function hideMessage(type) {
  const messageElement = document.getElementById(`booking-${type}`);
  if (messageElement) {
    messageElement.style.display = 'none';
  }
}

// Compute a user-facing title for a variant. If Shopify uses
// "Default Title" or the title doesn't contain a duration, fall back
// to the parsed duration minutes.
function getVariantDisplayTitle(service, variant) {
  // Always show just the service title. Duration appears in the subtitle.
  return service.title;
}

function showMessage(type, message) {
  const messageElement = document.getElementById(`booking-${type}`);
  if (messageElement) {
    messageElement.textContent = message;
    messageElement.style.display = 'block';
  }
}

function closeBookingModal() {
  const modal = document.getElementById('simplybook-modal');
  if (modal) {
    modal.style.display = 'none';
  }
  
  // Reset selection state
  currentSelection = {
    type: null,
    serviceId: null,
    staffId: null,
    variantId: null,
    selectedDate: null,
    selectedTime: null,
    locationId: null
  };
  
  showSelectionScreen();
  
  // Hide confirmation modal
  const confirmation = document.getElementById('booking-confirmation');
  if (confirmation) {
    confirmation.style.display = 'none';
  }
  
  // Clear selected time slot
  document.querySelectorAll('.simplybook-time-slot.selected').forEach(slot => {
    slot.classList.remove('selected');
  });
  
  hideMessage('error');
  hideMessage('success');
}

function closeConfirmationView() {
  const confirmation = document.getElementById('booking-confirmation');
  if (confirmation) {
    confirmation.style.display = 'none';
  }
  
  const formContainer = document.getElementById('booking-form-container');
  if (formContainer) {
    formContainer.style.display = 'block';
  }
  
  const mainCloseButton = document.getElementById('main-close-button');
  if (mainCloseButton) {
    mainCloseButton.style.display = 'flex';
  }
  
  document.querySelectorAll('.simplybook-time-slot.selected').forEach(slot => {
    slot.classList.remove('selected');
  });
  
  currentSelection.selectedTime = null;
  currentSelection.selectedDate = null;
  
  hideMessage('error');
  hideMessage('success');
}

function showSelectionScreen() {
  const selectionElement = document.getElementById('booking-selection');
  const formElement = document.getElementById('booking-form-container');
  
  if (selectionElement) {
    selectionElement.style.display = 'block';
  }
  if (formElement) {
    formElement.style.display = 'none';
  }
  
  hideMessage('error');
  hideMessage('success');
}

function showBookingForm() {
  const selectionElement = document.getElementById('booking-selection');
  const formElement = document.getElementById('booking-form-container');
  
  if (selectionElement) {
    selectionElement.style.display = 'none';
  }
  if (formElement) {
    formElement.style.display = 'block';
  }
  
  hideMessage('error');
  hideMessage('success');
  
  initializeCalendar();
  updateSelectedBarberInfo();
  const container = document.getElementById('service-menu-list');
  if (container && currentSelection.serviceExplicitlyChosen && currentSelection.serviceId && currentSelection.variantId) {
    container.setAttribute('data-collapsed', 'true');
  }
  populateServiceMenu();
  
  const forceMode = (bookingData?.locations?.length === 1) ? 'single' : null;
  populateLocationDropdown(forceMode);
}

function updateSelectedBarberInfo() {
  const container = document.getElementById('selected-barber-info');
  if (!container || !bookingData) return;
  
  // Auto-select single professional if there's only one with availability
  const availableStaff = (bookingData && Array.isArray(bookingData.staff))
    ? bookingData.staff.filter(function (s) { return s && s.isActive === true && hasStaffAvailabilityInNext3Months(s.id, currentSelection.locationId); })
    : [];
  
  if (availableStaff.length === 1 && !currentSelection.staffId) {
    currentSelection.staffId = availableStaff[0].id;
    currentSelection.type = 'staff';
  }
  
  if (currentSelection.staffId) {
    const staff = bookingData.staff.find(s => s.id === currentSelection.staffId);
    if (staff) {
      const avatarHtml = staff.avatar?.url 
        ? `<img src="${staff.avatar.url}" alt="${staff.name}" class="simplybook-selected-barber-avatar">` 
        : `<div class="simplybook-selected-barber-avatar" style="background: #f0f0f0; display: flex; align-items: center; justify-content: center; font-size: 18px; font-weight: bold; color: #666;">${staff.name.charAt(0)}</div>`;
      
      container.innerHTML = `
        <div class="simplybook-selected-barber-info">
          ${avatarHtml}
          <div class="simplybook-selected-barber-details">
            <h4>${staff.name}</h4>
            <p>${staff.title || 'Staff member'}</p>
          </div>
        </div>
      `;
    }
  } else if (currentSelection.serviceId) {
    const service = bookingData.services.find(s => s.id === currentSelection.serviceId);
    const variant = service?.variants.find(v => v.id === currentSelection.variantId);
    const serviceName = service && variant ? getVariantDisplayTitle(service, variant) : 'this service';
    
    container.innerHTML = `
      <div style="text-align: center; color: #666; padding: 20px;">
        <h4 style="margin-bottom: 10px; color: #333;">Any Available Professional</h4>
      </div>
    `;
  } else {
    container.innerHTML = `
      <div style="text-align: center; color: #666; padding: 20px;">
        <p>Select a service to view availability</p>
      </div>
    `;
  }
}

function populateServiceMenu() {
  const container = document.getElementById('service-menu-list');
  if (!container || !bookingData) return;
  
  container.innerHTML = '';
  const isCollapsed = container.getAttribute('data-collapsed') === 'true';
  
  // If collapsed and a selection exists, render only the selected service variant as a toggle
  if (isCollapsed && currentSelection.serviceExplicitlyChosen && currentSelection.serviceId && currentSelection.variantId) {
    const service = bookingData.services.find(s => s.id === currentSelection.serviceId);
    const variant = service?.variants.find(v => v.id === currentSelection.variantId);
    if (service && variant) {
      const serviceItem = document.createElement('div');
      serviceItem.className = 'simplybook-service-menu-item selected expandable';
      serviceItem.style.cursor = 'pointer';
      serviceItem.onclick = () => {
        container.setAttribute('data-collapsed', 'false');
        populateServiceMenu();
      };
      const durationText = (variant && variant.duration) ? ` • ${variant.duration} minutes` : ` • ${(bookingData?.timeSlotInterval || 60)} minutes`;
      const priceHtml = variant.price ? `<div class="price">$${variant.price}</div>` : '';
      serviceItem.innerHTML = `
        <h4>${getVariantDisplayTitle(service, variant)}</h4>
        <p>${service.body || 'Professional service'}${durationText}</p>
        ${priceHtml}
      `;
      container.appendChild(serviceItem);
      return;
    }
  }

  // Otherwise, render full list
  bookingData.services.forEach(service => {
    if (service.variants && service.variants.length > 0) {
      service.variants.forEach(variant => {
        const serviceItem = document.createElement('div');
        serviceItem.className = 'simplybook-service-menu-item';
        serviceItem.onclick = () => {
          selectServiceFromMenuVariant(service.id, variant.id);
          // collapse after selecting
          container.setAttribute('data-collapsed', 'true');
          populateServiceMenu();
        };
        
        if (currentSelection.serviceId === service.id && currentSelection.variantId === variant.id) {
          serviceItem.classList.add('selected');
        }
        
        const durationText = (variant && variant.duration) ? ` • ${variant.duration} minutes` : ` • ${(bookingData?.timeSlotInterval || 60)} minutes`;
        const priceHtml = variant.price ? `<div class="price">$${variant.price}</div>` : '';
        
        serviceItem.innerHTML = `
          <h4>${getVariantDisplayTitle(service, variant)}</h4>
          <p>${service.body || 'Professional service'}${durationText}</p>
          ${priceHtml}
        `;
        
        container.appendChild(serviceItem);
      });
    }
  });
}

function selectServiceFromMenuVariant(serviceId, variantId) {
  document.querySelectorAll('.simplybook-service-menu-item').forEach(item => {
    item.classList.remove('selected');
  });
  
  event.target.closest('.simplybook-service-menu-item').classList.add('selected');
  
  currentSelection.serviceId = serviceId;
  currentSelection.variantId = variantId;
  currentSelection.serviceExplicitlyChosen = true;

  // If there's only one active professional, auto-select them for convenience
  try {
    const activeStaff = (bookingData && Array.isArray(bookingData.staff))
      ? bookingData.staff.filter(function (s) { return s && s.isActive === true; })
      : [];
    if (activeStaff.length === 1) {
      currentSelection.staffId = activeStaff[0].id;
      currentSelection.type = 'staff';
    } else {
      if (currentSelection.type !== 'staff') {
        currentSelection.staffId = null;
        currentSelection.type = 'service';
      }
    }
  } catch (_) {
    if (currentSelection.type !== 'staff') {
      currentSelection.staffId = null;
      currentSelection.type = 'service';
    }
  }
  
  updateSelectedBarberInfo();
  updateCalendar();
  
  document.querySelectorAll('.simplybook-time-slot.selected').forEach(slot => {
    slot.classList.remove('selected');
  });
  currentSelection.selectedTime = null;
  currentSelection.selectedDate = null;
}

function populateLocationDropdown(forceDisplayMode = null) {
  const locationSelect = document.getElementById('location-select');
  const singleLocationDisplay = document.getElementById('single-location-display');
  const singleLocationName = document.getElementById('single-location-name');
  const singleLocationAddress = document.getElementById('single-location-address');
  
  if (!locationSelect || !bookingData?.locations) {
    return;
  }
  
  locationSelect.innerHTML = '';
  
  const serviceLocations = bookingData.locations.filter(location => {
    return location.offersServices !== false;
  });
  
  if (serviceLocations.length === 0) {
    locationSelect.innerHTML = '<option value="">No locations available for booking</option>';
    locationSelect.style.display = 'block';
    if (singleLocationDisplay) singleLocationDisplay.style.display = 'none';
    return;
  }
  
  const shouldShowAsSingle = serviceLocations.length === 1;
  
  if (shouldShowAsSingle) {
    const location = serviceLocations[0];
    currentSelection.locationId = location.id;
    
    if (singleLocationName) {
      singleLocationName.textContent = location.name;
    }
    if (singleLocationAddress) {
      const addressParts = [];
      if (location.address1) addressParts.push(location.address1);
      if (location.city) addressParts.push(location.city);
      if (location.province) addressParts.push(location.province);
      const fullAddress = addressParts.join(', ');
      singleLocationAddress.textContent = fullAddress;
    }
    
    if (singleLocationDisplay) {
      singleLocationDisplay.style.display = 'block';
    }
    locationSelect.style.display = 'none';
    
    updateCalendar();
  } else {
    locationSelect.innerHTML = '<option value="">Select a location</option>';
    serviceLocations.forEach(location => {
      const option = document.createElement('option');
      option.value = location.id;
      option.textContent = `${location.name} - ${location.address1}, ${location.city}`;
      locationSelect.appendChild(option);
    });
    
    locationSelect.style.display = 'block';
    if (singleLocationDisplay) {
      singleLocationDisplay.style.display = 'none';
    }
    
    const firstLocation = serviceLocations[0];
    locationSelect.value = firstLocation.id;
    currentSelection.locationId = firstLocation.id;
    updateCalendar();
  }
}

function initializeCalendar() {
  const today = new Date();
  currentWeekStart = getWeekStart(today);
  updateCalendar();
  
  document.getElementById('prev-week').addEventListener('click', () => {
    currentWeekStart = new Date(currentWeekStart.getTime() - 7 * 24 * 60 * 60 * 1000);
    updateCalendar();
  });
  
  document.getElementById('next-week').addEventListener('click', () => {
    currentWeekStart = new Date(currentWeekStart.getTime() + 7 * 24 * 60 * 60 * 1000);
    updateCalendar();
  });
  
  document.getElementById('location-select').addEventListener('change', (e) => {
    currentSelection.locationId = e.target.value;
    updateCalendar();
  });
}

function getWeekStart(date) {
  const d = new Date(date);
  const day = d.getDay();
  const diff = d.getDate() - day;
  return new Date(d.setDate(diff));
}

function updateCalendar() {
  updateCalendarHeader();
  renderCalendarDays();
}

function updateCalendarHeader() {
  const monthYear = document.getElementById('calendar-month-year');
  if (monthYear && currentWeekStart) {
    const options = { month: 'long', year: 'numeric' };
    monthYear.textContent = currentWeekStart.toLocaleDateString('en-US', options);
  }
}

function renderCalendarDays() {
  const calendarBody = document.getElementById('calendar-body');
  if (!calendarBody || !currentWeekStart) return;
  
  calendarBody.innerHTML = '';
  
  for (let i = 0; i < 7; i++) {
    const date = new Date(currentWeekStart.getTime() + i * 24 * 60 * 60 * 1000);
    const dayElement = createCalendarDay(date);
    calendarBody.appendChild(dayElement);
  }
}

function createCalendarDay(date) {
  const dayElement = document.createElement('div');
  dayElement.className = 'simplybook-calendar-day';
  
  const today = new Date();
  const isPast = date < today.setHours(0, 0, 0, 0);
  
  if (isPast) {
    dayElement.classList.add('disabled');
  }
  
  const dayNumber = document.createElement('div');
  dayNumber.className = 'simplybook-day-number';
  dayNumber.textContent = date.getDate();
  dayElement.appendChild(dayNumber);
  
  if (!isPast && currentSelection.serviceId && currentSelection.locationId) {
    const timeSlots = generateTimeSlots(date);
    timeSlots.forEach(slot => {
      const timeSlotElement = createTimeSlot(slot, date);
      dayElement.appendChild(timeSlotElement);
    });
  }
  
  return dayElement;
}

// Helper to get location hours for a specific date
function getLocationHoursForDate(date, locationId) {
  if (!bookingData || !locationId) return null;
  
  const location = bookingData.locations?.find(loc => loc.id === locationId);
  if (!location) return null;
  
  const dayOfWeek = getDayOfWeek(date);
  const dateStr = date.toISOString().split('T')[0]; // YYYY-MM-DD
  
  // Check for exceptions first (holidays, special hours)
  if (bookingData.locationHoursExceptions) {
    const exception = bookingData.locationHoursExceptions.find(ex => {
      if (ex.locationId !== locationId) return false;
      const startDate = new Date(ex.startDate).toISOString().split('T')[0];
      const endDate = new Date(ex.endDate).toISOString().split('T')[0];
      return dateStr >= startDate && dateStr <= endDate;
    });
    
    if (exception) {
      if (exception.closedAllDay) return null;
      if (exception.openTime && exception.closeTime) {
        return { startTime: exception.openTime, endTime: exception.closeTime };
      }
    }
  }
  
  // Check for location hours rules
  if (bookingData.locationHoursRules) {
    // Match the weekday numbering used in saveLocationHours.ts:
    // monday: 0, tuesday: 1, wednesday: 2, thursday: 3, friday: 4, saturday: 5, sunday: 6
    const weekdayMap = { monday: 0, tuesday: 1, wednesday: 2, thursday: 3, friday: 4, saturday: 5, sunday: 6 };
    const weekdayNum = weekdayMap[dayOfWeek];
    
    const matchingRules = bookingData.locationHoursRules.filter(r => {
      // Compare location IDs as strings to handle both string and number formats
      const ruleLocationId = String(r.locationId);
      const targetLocationId = String(locationId);
      if (ruleLocationId !== targetLocationId || r.weekday !== weekdayNum) return false;
      const now = new Date();
      const validFrom = r.validFrom ? new Date(r.validFrom) : null;
      const validTo = r.validTo ? new Date(r.validTo) : null;
      if (validFrom && now < validFrom) return false;
      if (validTo && now > validTo) return false;
      return true;
    });
    
    console.log(`[getLocationHoursForDate] Checking rules for ${dayOfWeek} (weekday ${weekdayNum}) at location ${locationId}:`, {
      allRulesForLocation: bookingData.locationHoursRules.filter(r => r.locationId === locationId),
      matchingRules: matchingRules
    });
    
    if (matchingRules.length > 0) {
      // Use the most recent rule (highest validFrom date, or first if no validFrom)
      const rule = matchingRules.sort((a, b) => {
        const aFrom = a.validFrom ? new Date(a.validFrom).getTime() : 0;
        const bFrom = b.validFrom ? new Date(b.validFrom).getTime() : 0;
        return bFrom - aFrom;
      })[0];
      
      if (rule && rule.openTime && rule.closeTime) {
        console.log(`[getLocationHoursForDate] Using rule for ${dayOfWeek} at location ${locationId}:`, {
          openTime: rule.openTime,
          closeTime: rule.closeTime,
          weekday: rule.weekday,
          ruleId: rule.id,
          validFrom: rule.validFrom,
          validTo: rule.validTo
        });
        return { startTime: rule.openTime, endTime: rule.closeTime };
      }
    } else {
      console.log(`[getLocationHoursForDate] No matching rules found for ${dayOfWeek} (weekday ${weekdayNum}) at location ${locationId}, falling back to legacy operatingHours`);
    }
  }
  
  // Fallback to legacy operatingHours from location
  if (location.operatingHours) {
    let operatingHours = location.operatingHours;
    if (typeof operatingHours === 'string') {
      try {
        operatingHours = JSON.parse(operatingHours);
      } catch (e) {
        return null;
      }
    }
    
    // Handle different formats
    if (operatingHours.mode === 'individual_days' && operatingHours.days) {
      const dayHours = operatingHours.days[dayOfWeek];
      if (dayHours && dayHours.enabled) {
        return { startTime: dayHours.from, endTime: dayHours.to };
      }
    } else if (operatingHours.mode === 'weekdays_weekends') {
      const isWeekend = dayOfWeek === 'saturday' || dayOfWeek === 'sunday';
      const hours = isWeekend ? operatingHours.weekends : operatingHours.weekdays;
      if (hours && hours.enabled) {
        return { startTime: hours.from, endTime: hours.to };
      }
    } else if (operatingHours[dayOfWeek]) {
      // Legacy format: { monday: { isOpen: true, startTime: "09:00", endTime: "18:00" } }
      const dayHours = operatingHours[dayOfWeek];
      if (dayHours && (dayHours.isOpen || dayHours.enabled)) {
        return { 
          startTime: dayHours.startTime || dayHours.from || '09:00',
          endTime: dayHours.endTime || dayHours.to || '17:00'
        };
      }
    }
  }
  
  return null;
}

function generateTimeSlots(date) {
  if (!currentSelection.serviceId || !currentSelection.locationId || !bookingData) {
    console.log('[generateTimeSlots] Missing required data:', {
      serviceId: currentSelection.serviceId,
      locationId: currentSelection.locationId,
      hasBookingData: !!bookingData
    });
    return [];
  }
  
  const qualifiedStaff = getQualifiedStaffForService(currentSelection.serviceId);
  if (qualifiedStaff.length === 0) {
    console.log('[generateTimeSlots] No qualified staff found');
    return [];
  }
  
  const dayOfWeek = getDayOfWeek(date);
  const aggregatedSlots = new Set();
  
  // Get location hours for this date
  const locationHours = getLocationHoursForDate(date, currentSelection.locationId);
  const locationStartTime = locationHours ? parseTime(locationHours.startTime) : null;
  const locationEndTime = locationHours ? parseTime(locationHours.endTime) : null;
  
  console.log('[generateTimeSlots] Debug info:', {
    date: date.toISOString().split('T')[0],
    dayOfWeek,
    locationId: currentSelection.locationId,
    qualifiedStaffCount: qualifiedStaff.length,
    qualifiedStaffIds: qualifiedStaff,
    hasLocationHours: !!locationHours,
    locationHours: locationHours,
    locationStartTime,
    locationEndTime,
    locationStartTimeFormatted: locationStartTime !== null ? formatTime(locationStartTime) : null,
    locationEndTimeFormatted: locationEndTime !== null ? formatTime(locationEndTime) : null
  });
  
  // Generate time slots for the given date
  qualifiedStaff.forEach(staffId => {
    // First, try to find specific date availability for the exact date being checked
    const dateAvailability = bookingData.staffDateAvailability.find(avail => {
      if (avail.staffId !== staffId || (avail.locationId && avail.locationId !== currentSelection.locationId)) {
        return false;
      }
      
      const availDate = new Date(avail.date);
      const availDateLocal = new Date(
        availDate.getUTCFullYear(),
        availDate.getUTCMonth(),
        availDate.getUTCDate()
      );
      
      const currentDate = new Date(
        date.getFullYear(),
        date.getMonth(), 
        date.getDate()
      );
      
      return currentDate.getTime() === availDateLocal.getTime();
    });
    
    // If no specific date availability, fall back to weekly availability for the correct day
    const staffAvailability = bookingData.staffAvailability.find(avail => 
      avail.staffId === staffId &&
      (avail.locationId === currentSelection.locationId || !avail.locationId) &&
      avail.dayOfWeek && Array.isArray(avail.dayOfWeek) && avail.dayOfWeek.includes(dayOfWeek) &&
      (avail.isAvailable !== false)
    );
    
    console.log(`[generateTimeSlots] Staff ${staffId}:`, {
      hasDateAvailability: !!dateAvailability,
      dateAvailability: dateAvailability,
      hasStaffAvailability: !!staffAvailability,
      staffAvailability: staffAvailability,
      allStaffAvailability: bookingData.staffAvailability.filter(a => a.staffId === staffId)
    });
    
    // Use specific date availability if available, otherwise fall back to weekly availability
    let availability = dateAvailability || staffAvailability;
    
    const hasDefinedAvailability = staffHasDefinedAvailability(staffId, currentSelection.locationId);
    const noLocationSelected = !currentSelection.locationId;

    if (!availability && locationHours && (noLocationSelected || !hasDefinedAvailability)) {
      console.log(`[generateTimeSlots] Staff ${staffId}: Using location hours as fallback`);
      availability = { startTime: locationHours.startTime, endTime: locationHours.endTime };
    }
    
    // If we still don't have availability, skip this staff member
    if (!availability) {
      console.log(`[generateTimeSlots] Staff ${staffId}: No availability found, skipping`);
      return; // Continue to next staff member
    }
    
    let startTime = parseTime(availability.startTime);
    let endTime = parseTime(availability.endTime);
    
    // Always constrain to location hours if they exist (even if we have staff availability)
    if (locationStartTime !== null && startTime < locationStartTime) {
      console.log(`[generateTimeSlots] Staff ${staffId}: Constraining startTime from ${formatTime(startTime)} to ${formatTime(locationStartTime)}`);
      startTime = locationStartTime;
    }
    if (locationEndTime !== null && endTime > locationEndTime) {
      console.log(`[generateTimeSlots] Staff ${staffId}: Constraining endTime from ${formatTime(endTime)} to ${formatTime(locationEndTime)}`);
      endTime = locationEndTime;
    }
    
    // Only generate slots if we have a valid time range
    if (startTime >= endTime) {
      console.log(`[generateTimeSlots] Staff ${staffId}: Invalid time range (startTime ${formatTime(startTime)} >= endTime ${formatTime(endTime)}), skipping`);
      return; // Skip if invalid time range
    }
    
    const timeSlotInterval = bookingData.timeSlotInterval || 30;
    
    console.log(`[generateTimeSlots] Staff ${staffId}: Generating slots from ${formatTime(startTime)} to ${formatTime(endTime)}, interval: ${timeSlotInterval} minutes`);
    
    // Generate time slots that align with the interval
    // Note: The loop condition is < endTime, so we generate slots up to but not including the end time
    // This means if endTime is 4 PM (960 minutes), the last slot will be 3:30 PM (930 minutes) with a 30-minute interval
    const generatedSlots = [];
    for (let minutes = startTime; minutes < endTime; minutes += timeSlotInterval) {
      const time = formatTime(minutes);
      generatedSlots.push(time);
      aggregatedSlots.add(time);
    }
    console.log(`[generateTimeSlots] Staff ${staffId}: Generated ${generatedSlots.length} slots:`, generatedSlots);
  });
  
  const sortedSlots = Array.from(aggregatedSlots).sort();
  console.log('[generateTimeSlots] Final slots:', sortedSlots);
  return sortedSlots;
}

function getDayOfWeek(date) {
  const days = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];
  return days[date.getDay()];
}

function parseTime(timeString) {
  if (!timeString) return 0;
  
  // Handle 12-hour format (e.g., "1:00 PM" or "1:00PM")
  const trimmed = timeString.trim().toUpperCase();
  const hasAM = trimmed.includes('AM');
  const hasPM = trimmed.includes('PM');
  
  if (hasAM || hasPM) {
    const timePart = trimmed.replace(/\s*(AM|PM)/, '');
    const [hours, minutes] = timePart.split(':').map(Number);
    let hour24 = hours;
    if (hasPM && hours !== 12) {
      hour24 = hours + 12;
    } else if (hasAM && hours === 12) {
      hour24 = 0;
    }
    return hour24 * 60 + (minutes || 0);
  }
  
  // Handle 24-hour format (e.g., "13:00" or "1:00")
  const [hours, minutes] = timeString.split(':').map(Number);
  return hours * 60 + (minutes || 0);
}

function formatTime(minutes) {
  const hours = Math.floor(minutes / 60);
  const mins = minutes % 60;
  return `${hours.toString().padStart(2, '0')}:${mins.toString().padStart(2, '0')}`;
}

function createTimeSlot(time, date) {
  const timeSlotElement = document.createElement('button');
  timeSlotElement.className = 'simplybook-time-slot';
  timeSlotElement.textContent = time;
  timeSlotElement.type = 'button';
  
  const isAvailable = isTimeSlotAvailable(time, date);
  
  if (!isAvailable) {
    timeSlotElement.classList.add('unavailable');
    timeSlotElement.disabled = true;
  } else {
    timeSlotElement.addEventListener('click', () => {
      selectTimeSlot(time, date, timeSlotElement);
    });
  }
  return timeSlotElement;
}

function isTimeSlotAvailable(time, date) {
  if (!currentSelection.serviceId || !currentSelection.locationId || !bookingData) {
    return false;
  }
  
  const qualifiedStaff = getQualifiedStaffForService(currentSelection.serviceId);
  if (qualifiedStaff.length === 0) {
    return false;
  }
  
  const availableStaff = qualifiedStaff.filter(staffId => {
    return isTimeSlotAvailableForStaff(time, date, staffId);
  });
  
  return availableStaff.length > 0;
}

function isTimeSlotAvailableForStaff(time, date, staffId) {
  if (!staffId || !currentSelection.locationId || !bookingData) {
    return false;
  }

  const now = new Date();
  const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
  const appointmentDate = new Date(date.getFullYear(), date.getMonth(), date.getDate());
  
  if (appointmentDate.getTime() === today.getTime()) {
    const currentTime = now.getHours() * 60 + now.getMinutes();
    const slotTime = parseTime(time);
    const gracePeriod = 15;
    
    if (currentTime > slotTime + gracePeriod) {
      console.log(`Time slot ${time} is in the past (current: ${currentTime}, slot: ${slotTime})`);
      return false;
    }
  }

  const dayOfWeek = getDayOfWeek(date);
  
  // Get location hours for this date as fallback
  const locationHours = getLocationHoursForDate(date, currentSelection.locationId);
  
  // First, try to find specific date availability for the exact date being checked
  const dateAvailability = bookingData.staffDateAvailability.find(avail => {
    if (avail.staffId !== staffId || (avail.locationId && avail.locationId !== currentSelection.locationId)) {
      return false;
    }
    
    const availDate = new Date(avail.date);
    const availDateLocal = new Date(
      availDate.getUTCFullYear(),
      availDate.getUTCMonth(),
      availDate.getUTCDate()
    );
    
    const currentDate = new Date(
      date.getFullYear(),
      date.getMonth(), 
      date.getDate()
    );
    
    const isMatch = currentDate.getTime() === availDateLocal.getTime();
    // Found specific date availability
    
    return isMatch;
  });
  
  // If no specific date availability, fall back to weekly availability for the correct day
  const staffAvailability = bookingData.staffAvailability.find(avail => 
    avail.staffId === staffId &&
    (avail.locationId === currentSelection.locationId || !avail.locationId) &&
    avail.dayOfWeek && avail.dayOfWeek.includes(dayOfWeek) &&
    (avail.isAvailable !== false)
  );
  
  // Use specific date availability if available, otherwise fall back to weekly availability
  let availability = dateAvailability || staffAvailability;
  
  const hasDefinedAvailability = staffHasDefinedAvailability(staffId, currentSelection.locationId);
  const noLocationSelected = !currentSelection.locationId;

  if (!availability && locationHours && (noLocationSelected || !hasDefinedAvailability)) {
    console.log(`[generateTimeSlots] Staff ${staffId}: Using location hours as fallback`);
    availability = { startTime: locationHours.startTime, endTime: locationHours.endTime };
  }
  
  if (!availability || (availability.isAvailable !== undefined && availability.isAvailable === false)) {
    return false;
  }
  
  const slotTime = parseTime(time);
  const startTime = parseTime(availability.startTime);
  const endTime = parseTime(availability.endTime);
  
  const serviceDuration = getServiceDuration();
  const slotEndTime = slotTime + serviceDuration;
  
  if (!(slotTime >= startTime && slotEndTime <= endTime)) {
    return false;
  }
  
  const hasConflict = checkBookingConflictsForStaff(date, time, serviceDuration, staffId);
  return !hasConflict;
}

function getServiceDuration() {
  if (!currentSelection.serviceId || !bookingData) return bookingData.timeSlotInterval || 60;
  
  const service = bookingData.services.find(s => s.id === currentSelection.serviceId);
  if (!service || !service.variants || service.variants.length === 0) return bookingData.timeSlotInterval || 60;
  
  const variant = currentSelection.variantId 
    ? service.variants.find(v => v.id === currentSelection.variantId)
    : service.variants[0];
  
  return (variant && variant.duration) ? variant.duration : (bookingData.timeSlotInterval || 60);
}

function staffHasAvailabilityForLocation(staffId, locationId) {
  if (!locationId) {
    return true;
  }
  
  const today = new Date();
  const todayStart = new Date(today.getFullYear(), today.getMonth(), today.getDate());
  const threeMonthsFromNow = new Date(todayStart.getTime() + (90 * 24 * 60 * 60 * 1000));
  
  const hasWeekly = Array.isArray(bookingData?.staffAvailability) && bookingData.staffAvailability.some(avail =>
    avail.staffId === staffId &&
    avail.locationId === locationId &&
    (avail.isAvailable !== false) &&
    avail.dayOfWeek && Array.isArray(avail.dayOfWeek) && avail.dayOfWeek.length > 0
  );
  
  if (hasWeekly) {
    return true;
  }
  
  const hasDateAvailability = Array.isArray(bookingData?.staffDateAvailability) && bookingData.staffDateAvailability.some(dateAvail => {
    if (dateAvail.staffId !== staffId || dateAvail.locationId !== locationId || dateAvail.isAvailable === false) {
      return false;
    }
    
    const availDate = new Date(dateAvail.date);
    const availDateLocal = new Date(
      availDate.getUTCFullYear(),
      availDate.getUTCMonth(),
      availDate.getUTCDate()
    );
    return availDateLocal >= todayStart && availDateLocal <= threeMonthsFromNow;
  });
  
  return hasDateAvailability;
}

function getQualifiedStaffForService(serviceId) {
  if (!bookingData || !bookingData.staff || !Array.isArray(bookingData.staff)) {
    console.log('[getQualifiedStaffForService] No booking data or staff array');
    return [];
  }
  
  console.log('[getQualifiedStaffForService] All staff:', bookingData.staff.map(s => ({
    id: s.id,
    name: s.name,
    isActive: s.isActive
  })));
  
  if (currentSelection.staffId) {
    const selectedStaff = bookingData.staff.find(staff => staff.id === currentSelection.staffId);
    if (
      selectedStaff &&
      (selectedStaff.isActive === true || selectedStaff.isActive === undefined) &&
      staffHasAvailabilityForLocation(selectedStaff.id, currentSelection.locationId)
    ) {
      console.log('[getQualifiedStaffForService] Selected staff found:', selectedStaff.id);
      return [selectedStaff.id];
    } else {
      console.log('[getQualifiedStaffForService] Selected staff not found, inactive, or unavailable at location:', currentSelection.staffId);
      return [];
    }
  }
  
  // Since API already filters for active staff, treat undefined as active but require location availability
  const filteredStaff = bookingData.staff.filter(staff => {
    const isActive = staff.isActive === true || staff.isActive === undefined;
    return isActive && staffHasAvailabilityForLocation(staff.id, currentSelection.locationId);
  });
  
  console.log('[getQualifiedStaffForService] Filtered staff count:', filteredStaff.length, filteredStaff.map(s => s.id));
  
  return filteredStaff.map(staff => staff.id);
}

function checkBookingConflictsForStaff(date, time, serviceDuration, staffId) {
  if (!bookingData.existingBookings || !Array.isArray(bookingData.existingBookings)) {
    return false;
  }
  
  const proposedDate = new Date(date);
  const [hours, minutes] = time.split(':').map(Number);
  const proposedStart = new Date(
    proposedDate.getFullYear(),
    proposedDate.getMonth(),
    proposedDate.getDate(),
    hours,
    minutes
  );
  
  const proposedEnd = new Date(proposedStart.getTime() + (serviceDuration * 60 * 1000));
  
  const targetStaffId = String(staffId);
  
  // Check for booking conflicts
  
  const conflictingBookings = bookingData.existingBookings.filter(booking => {
    const bookingStaffId = String(booking.staffId);
    
    if (bookingStaffId !== targetStaffId) {
      return false;
    }
    
    const existingStart = new Date(booking.scheduledAt);
    const existingDuration = booking.duration || 60;
    const existingEnd = new Date(existingStart.getTime() + (existingDuration * 60 * 1000));
    
    const hasOverlap = (proposedStart < existingEnd) && (proposedEnd > existingStart);
    
    // Conflict detected
    
    return hasOverlap;
  });
  
  return conflictingBookings.length > 0;
}

function selectTimeSlot(time, date, element) {
  document.querySelectorAll('.simplybook-time-slot.selected').forEach(slot => {
    slot.classList.remove('selected');
  });
  
  element.classList.add('selected');
  
  currentSelection.selectedTime = time;
  currentSelection.selectedDate = date;
  
  if (currentSelection.serviceId && !currentSelection.staffId) {
    showBarberSelectionForTimeSlot(time, date);
  } else {
    showBookingConfirmation();
  }
}

function showBarberSelectionForTimeSlot(time, date) {
  const barberModal = document.getElementById('barber-selection-modal');
  const formContainer = document.getElementById('booking-form-container');
  if (!barberModal || !formContainer) return;
  
  const qualifiedStaff = getQualifiedStaffForService(currentSelection.serviceId);
  
  const availableStaff = qualifiedStaff.filter(staffId => {
    return isTimeSlotAvailableForStaff(time, date, staffId);
  });
  
  if (availableStaff.length === 0) {
    showMessage('error', 'No professionals are available at this time. Please select a different time slot.');
    return;
  }
  
  const barbersList = document.getElementById('available-barbers-list');
  barbersList.innerHTML = '';
  
  availableStaff.forEach(staffId => {
    const staff = bookingData.staff.find(s => s.id === staffId);
    if (!staff) return;
    
    const barberChoice = document.createElement('div');
    barberChoice.className = 'simplybook-barber-choice';
    barberChoice.onclick = () => selectBarberForTimeSlot(staffId);
    
    const avatarHtml = staff.avatar?.url 
      ? `<img src="${staff.avatar.url}" alt="${staff.name}" class="simplybook-barber-choice-avatar">` 
      : `<div class="simplybook-barber-choice-avatar" style="background: #f0f0f0; display: flex; align-items: center; justify-content: center; font-size: 24px; font-weight: bold; color: #666;">${staff.name.charAt(0)}</div>`;
    
    barberChoice.innerHTML = `
      ${avatarHtml}
      <div class="simplybook-barber-choice-content">
        <div class="simplybook-barber-choice-name">${staff.name}</div>
        <div class="simplybook-barber-choice-bio">${staff.title || 'Staff member'}</div>
      </div>
    `;
    
    barbersList.appendChild(barberChoice);
  });
  
  formContainer.style.display = 'none';
  barberModal.style.display = 'block';
}

function selectBarberForTimeSlot(staffId) {
  currentSelection.staffId = staffId;
  
  const barberModal = document.getElementById('barber-selection-modal');
  if (barberModal) {
    barberModal.style.display = 'none';
  }
  
  showBookingConfirmation();
}

function cancelBarberSelection() {
  const barberModal = document.getElementById('barber-selection-modal');
  const formContainer = document.getElementById('booking-form-container');
  
  if (barberModal) {
    barberModal.style.display = 'none';
  }
  
  if (formContainer) {
    formContainer.style.display = 'block';
  }
  
  document.querySelectorAll('.simplybook-time-slot.selected').forEach(slot => {
    slot.classList.remove('selected');
  });
  
  currentSelection.selectedTime = null;
  currentSelection.selectedDate = null;
  
  hideMessage('error');
  hideMessage('success');
}

function showBookingConfirmation() {
  const confirmation = document.getElementById('booking-confirmation');
  const formContainer = document.getElementById('booking-form-container');
  
  if (!confirmation || !formContainer) {
    return;
  }
  
  const service = bookingData.services.find(s => s.id === currentSelection.serviceId);
  const staff = bookingData.staff.find(s => s.id === currentSelection.staffId);
  const location = bookingData.locations.find(l => l.id === currentSelection.locationId);
  const variant = service?.variants.find(v => v.id === currentSelection.variantId);
  
  if (!service || !staff || !location || !variant) return;
  
  const details = document.getElementById('booking-details');
  const notes = document.getElementById('notes').value;
  
  // Pretty date with ordinal, e.g., "Oct 15th"
  const formatDatePretty = (d) => {
    try {
      return d.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
    } catch (e) {
      // Fallback if locale formatting fails
      const month = d.toLocaleString('en-US', { month: 'short' });
      return `${month} ${d.getDate()}`;
    }
  };

  details.innerHTML = `
    <div class="simplybook-booking-detail-row">
      <span class="simplybook-booking-detail-label">Service:</span>
      <span class="simplybook-booking-detail-value">${getVariantDisplayTitle(service, variant)}</span>
    </div>
    <div class="simplybook-booking-detail-row">
      <span class="simplybook-booking-detail-label">Barber:</span>
      <span class="simplybook-booking-detail-value">${staff.name}</span>
    </div>
    <div class="simplybook-booking-detail-row">
      <span class="simplybook-booking-detail-label">Date & Time:</span>
      <span class="simplybook-booking-detail-value">${formatDatePretty(currentSelection.selectedDate)} at ${formatTime12Hour(currentSelection.selectedTime)}</span>
    </div>
    <div class="simplybook-booking-detail-row">
      <span class="simplybook-booking-detail-label">Location:</span>
      <span class="simplybook-booking-detail-value">${location.name}</span>
    </div>
    <div class="simplybook-booking-detail-row">
      <span class="simplybook-booking-detail-label">Duration:</span>
      <span class="simplybook-booking-detail-value">${variant.duration || 60} minutes</span>
    </div>
    ${notes ? `<div class="simplybook-booking-detail-row">
      <span class="simplybook-booking-detail-label">Notes:</span>
      <span class="simplybook-booking-detail-value">${notes}</span>
    </div>` : ''}
    <div class="simplybook-booking-detail-row">
      <span class="simplybook-booking-detail-label">Total:</span>
      <span class="simplybook-booking-detail-value">$${variant.price || 'N/A'}</span>
    </div>
  `;
  
  formContainer.style.display = 'none';
  confirmation.style.display = 'block';
  
  const mainCloseButton = document.getElementById('main-close-button');
  if (mainCloseButton) {
    mainCloseButton.style.display = 'none';
  }
}

function cancelBooking() {
  const confirmation = document.getElementById('booking-confirmation');
  const formContainer = document.getElementById('booking-form-container');
  const barberModal = document.getElementById('barber-selection-modal');
  
  if (confirmation) {
    confirmation.style.display = 'none';
  }
  
  if (barberModal) {
    barberModal.style.display = 'none';
  }
  
  if (formContainer) {
    formContainer.style.display = 'block';
  }
  
  const mainCloseButton = document.getElementById('main-close-button');
  if (mainCloseButton) {
    mainCloseButton.style.display = 'flex';
  }
  
  document.querySelectorAll('.simplybook-time-slot.selected').forEach(slot => {
    slot.classList.remove('selected');
  });
  
  currentSelection.selectedTime = null;
  currentSelection.selectedDate = null;
  
  hideMessage('error');
  hideMessage('success');
}

async function confirmBooking() {
  const confirmBtn = document.getElementById('confirm-booking-btn');
  const originalText = confirmBtn.textContent;
  
  try {
    confirmBtn.textContent = 'Adding...';
    confirmBtn.disabled = true;
    
    const service = bookingData.services.find(s => s.id === currentSelection.serviceId);
    const staff = bookingData.staff.find(s => s.id === currentSelection.staffId);
    const location = bookingData.locations.find(l => l.id === currentSelection.locationId);
    const variant = service?.variants.find(v => v.id === currentSelection.variantId);
    const notes = document.getElementById('notes').value;
    
    // Get the selected location's timezone
    const locationTimezone = location?.timeZone || 'America/New_York';
    
    // Parse the selected date and time
    const selectedDate = new Date(currentSelection.selectedDate);
    const [timeHours, timeMinutes] = currentSelection.selectedTime.split(':').map(Number);
    
    // Convert the selected time (in location timezone) to UTC
    // Create a date string in ISO format for the location timezone
    const year = selectedDate.getFullYear();
    const month = selectedDate.getMonth() + 1;
    const day = selectedDate.getDate();
    
    // Create a date string representing the local time in the location's timezone
    const dateTimeStr = `${year}-${String(month).padStart(2, '0')}-${String(day).padStart(2, '0')}T${String(timeHours).padStart(2, '0')}:${String(timeMinutes).padStart(2, '0')}:00`;
    
    // Use Intl.DateTimeFormat to convert from location timezone to UTC
    // We'll find the UTC time that produces our target time in the location timezone
    let scheduledAtUTC = null;
    
    // Try different UTC hours until we find one that formats to our target in location timezone
    for (let utcHour = 0; utcHour < 24; utcHour++) {
      const testUTC = new Date(Date.UTC(year, month - 1, day, utcHour, timeMinutes, 0));
      const formatter = new Intl.DateTimeFormat('en-US', {
        timeZone: locationTimezone,
        hour: '2-digit',
        minute: '2-digit',
        hour12: false,
      });
      const formatted = formatter.format(testUTC);
      if (formatted === `${String(timeHours).padStart(2, '0')}:${String(timeMinutes).padStart(2, '0')}`) {
        scheduledAtUTC = testUTC;
        break;
      }
    }
    
    // Fallback: if we couldn't find a match, estimate based on common timezone offsets
    if (!scheduledAtUTC) {
      // For Pacific Time (UTC-8 in winter, UTC-7 in summer), add hours
      // For Eastern Time (UTC-5 in winter, UTC-4 in summer), add hours
      const offsetHours = locationTimezone.includes('Los_Angeles') ? 8 : 
                          locationTimezone.includes('New_York') ? 5 : 5; // Default to EST
      scheduledAtUTC = new Date(Date.UTC(year, month - 1, day, timeHours + offsetHours, timeMinutes, 0));
    }
    
    const scheduledAt = scheduledAtUTC;
    
    const shopifyVariantId = variant.shopifyVariantId || variant.variantId;
    
    if (shopifyVariantId) {
      const cartItemData = {
        id: shopifyVariantId,
        quantity: 1,
        properties: {
          'Booking Time': formatTime12Hour(currentSelection.selectedTime),
          'Booking Date': currentSelection.selectedDate.toLocaleDateString('en-US', {
            year: 'numeric',
            month: 'long',
            day: 'numeric'
          }),
          'Booked With': staff.name,
          'Notes': notes || '',
          // hidden private metadata so it doesn't render in cart
          '_staff_id': currentSelection.staffId,
          '_location_id': currentSelection.locationId,
          // Show location name only if there are multiple locations
          ...(bookingData.locations && bookingData.locations.length > 1 ? {
            'Location Name': location.name
          } : {
            '_location_name': location.name
          })
        }
      };
      
      confirmBtn.innerHTML = '<span class="spinner"></span> Adding to Cart...';
      confirmBtn.disabled = true;
      
      // Adding booking to cart
      
      try {
        const cartResponse = await fetch('/cart/add.js', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(cartItemData)
        });
        
        if (cartResponse.ok) {
          window.location.href = '/cart';
        } else {
          const cartError = await cartResponse.text();
          
          let errorMessage = 'Failed to add booking to cart. Please try again.';
          
          // Parse the error response to provide better error messages
          try {
            const errorData = JSON.parse(cartError);
            if (errorData.description === 'Cannot find variant') {
              errorMessage = 'This service is not available for online booking. Please contact us directly to book this service.';
            } else if (errorData.description) {
              errorMessage = `Booking error: ${errorData.description}`;
            }
          } catch (parseError) {
            // If we can't parse the error, use the generic message
          }
          
          showMessage('error', errorMessage);
          confirmBtn.innerHTML = originalText;
          confirmBtn.disabled = false;
        }
      } catch (error) {
        showMessage('error', 'Failed to add booking to cart. Please try again.');
        confirmBtn.innerHTML = originalText;
        confirmBtn.disabled = false;
      }
      
    } else {
      showMessage('error', 'This service cannot be booked online. Please contact us directly.');
    }
    
  } catch (error) {
    showMessage('error', error.message || 'Failed to add booking to cart. Please try again.');
    confirmBtn.innerHTML = originalText;
    confirmBtn.disabled = false;
  }
}

function formatTime12Hour(timeString) {
  try {
    if (!timeString || !timeString.includes(':')) {
      return timeString;
    }
    
    const [hours, minutes] = timeString.split(':').map(Number);
    
    if (isNaN(hours) || isNaN(minutes)) {
      return timeString;
    }
    
    const timeObj = new Date();
    timeObj.setHours(hours, minutes);
    
    const formatted = timeObj.toLocaleTimeString('en-US', {
      hour: 'numeric',
      minute: '2-digit',
      hour12: true
    });
    
    return formatted;
  } catch (error) {
    return timeString;
  }
}

function hasStaffAvailabilityInNext3Months(staffId, locationId) {
  if (!bookingData) {
    return false;
  }
  
  const targetLocationId = locationId || currentSelection.locationId;
  if (!targetLocationId) {
    return false;
  }
  
  const today = new Date();
  const todayStart = new Date(today.getFullYear(), today.getMonth(), today.getDate());
  const threeMonthsFromNow = new Date(todayStart.getTime() + (90 * 24 * 60 * 60 * 1000));
  
  const hasWeeklyAvailability = Array.isArray(bookingData.staffAvailability) && bookingData.staffAvailability.some(avail =>
    avail.staffId === staffId &&
    avail.locationId === targetLocationId &&
    (avail.isAvailable !== false) &&
    avail.dayOfWeek && Array.isArray(avail.dayOfWeek) && avail.dayOfWeek.length > 0
  );
  
  if (hasWeeklyAvailability) {
    return true;
  }
  
  const hasDateAvailability = Array.isArray(bookingData.staffDateAvailability) && bookingData.staffDateAvailability.some(dateAvail => {
    if (dateAvail.staffId !== staffId || dateAvail.locationId !== targetLocationId || dateAvail.isAvailable === false) {
      return false;
    }
    
    const availDate = new Date(dateAvail.date);
    const availDateLocal = new Date(
      availDate.getUTCFullYear(),
      availDate.getUTCMonth(),
      availDate.getUTCDate()
    );
    return availDateLocal >= todayStart && availDateLocal <= threeMonthsFromNow;
  });
  
  return hasDateAvailability;
}

function staffHasDefinedAvailability(staffId, locationId) {
  const hasWeekly = Array.isArray(bookingData?.staffAvailability) && bookingData.staffAvailability.some(avail =>
    avail.staffId === staffId &&
    (avail.locationId === locationId || !avail.locationId)
  );

  if (hasWeekly) {
    return true;
  }

  const hasDate = Array.isArray(bookingData?.staffDateAvailability) && bookingData.staffDateAvailability.some(avail =>
    avail.staffId === staffId &&
    (avail.locationId === locationId || !avail.locationId)
  );

  return hasDate;
}

function selectService(serviceId, variantId) {
  currentSelection.type = 'service';
  currentSelection.serviceId = serviceId;
  currentSelection.variantId = variantId;
  currentSelection.staffId = null;
  currentSelection.serviceExplicitlyChosen = true;
  showBookingForm();
}

function selectStaff(staffId) {
  currentSelection.type = 'staff';
  currentSelection.staffId = staffId;
  currentSelection.serviceExplicitlyChosen = false; // reset explicit choice when user chooses a barber
  
  if (bookingData && bookingData.services && bookingData.services.length > 0) {
    const firstService = bookingData.services[0];
    if (firstService.variants && firstService.variants.length > 0) {
      const firstVariant = firstService.variants[0];
      currentSelection.serviceId = firstService.id;
      currentSelection.variantId = firstVariant.id;
    }
  }
  
  showBookingForm();
}

async function openBookingModal() {
  
  const modal = document.getElementById('simplybook-modal');
  if (!modal) {
    return;
  }

  try {
    // Move modal to <body> to avoid theme stacking/overflow contexts hiding it
    if (modal.parentElement !== document.body) {
      document.body.appendChild(modal);
      modal.__movedToBody = true;
    }
  } catch (moveErr) {
    
  }
  
  try {
    modal.style.setProperty('display', 'block', 'important');
    modal.style.visibility = 'visible';
    modal.style.opacity = '1';
    // Force reflow for some browsers
    void modal.offsetHeight;
    
  } catch (styleErr) {
    
  }
  
  currentSelection = {
    type: null,
    serviceId: null,
    staffId: null,
    variantId: null,
    selectedDate: null,
    selectedTime: null,
    locationId: null
  };
  
  setLoading(true);
  
  try {
    if (!bookingData) {
      bookingDataPromise = bookingDataPromise || loadBookingData();
      await bookingDataPromise;
    }
    
    populateServiceButtons();
    populateStaffButtons();

    // If there's only one active professional, reflect that selection in the sidebar
    try {
      const activeStaff = (bookingData && Array.isArray(bookingData.staff))
        ? bookingData.staff.filter(function (s) { return s && s.isActive === true; })
        : [];
      if (activeStaff.length === 1) {
        currentSelection.staffId = activeStaff[0].id;
        currentSelection.type = 'staff';
      }
    } catch (_) {}
    
    setLoading(false);
    showSelectionScreen();
    
  } catch (error) {
    showMessage('error', `Failed to load booking options: ${error.message}`);
    setLoading(false);
  }
}

// Ensure the function is available in themes that restrict inline handlers or change script scoping
try {
  if (typeof window !== 'undefined') {
    window.openBookingModal = openBookingModal;
    // Robust binding that works across Online Store 2.0 dynamic rendering
    function bindBookingButton() {
      var buttons = document.querySelectorAll('#simplybook-booking-btn, .simplybook-booking-btn, [data-open-booking-modal]');
      if (!buttons || buttons.length === 0) return;
      buttons.forEach(function(btn){
        if (btn.__simplybookBound) return;
        // Remove inline onclick to avoid double-firing or blocked inline handlers
        if (btn.hasAttribute && btn.hasAttribute('onclick')) {
          try { btn.removeAttribute('onclick'); } catch(_) {}
        }
        btn.addEventListener('click', function (e) {
          if (typeof openBookingModal === 'function') {
            e.preventDefault();
            e.stopPropagation();
            openBookingModal();
          }
        });
        btn.__simplybookBound = true;
      });
    }

    // Run immediately if DOM is already loaded
    if (document.readyState !== 'loading') { bindBookingButton(); }
    // Also on DOMContentLoaded (for classic loads)
    document.addEventListener('DOMContentLoaded', function(){ bindBookingButton(); });
    // And observe for dynamic section renders
    try {
      var observer = new MutationObserver(function () { bindBookingButton(); });
      observer.observe(document.documentElement || document.body, { childList: true, subtree: true });
    } catch (_) {}

    // Last-resort delegated click handler in case button is replaced after binding
    document.addEventListener('click', function(e){
      var target = e.target;
      if (!target) return;
      var btn = target.closest && target.closest('#simplybook-booking-btn, .simplybook-booking-btn, [data-open-booking-modal]');
      if (btn) {
        if (typeof openBookingModal === 'function') {
          e.preventDefault();
          openBookingModal();
        }
      }
    }, true);
  }
} catch (_) {
  // no-op
}

async function loadBookingData() {
  try {
    const shopDomain = window.Shopify?.shop?.myshopifyDomain || window.location.hostname;
    
    // Log shop domain detection
    console.log('SimplyBook: Shop domain detection', {
      'window.Shopify?.shop?.myshopifyDomain': window.Shopify?.shop?.myshopifyDomain,
      'window.location.hostname': window.location.hostname,
      'selected shopDomain': shopDomain
    });
    
    // Log AppConfig availability and values
    console.log('SimplyBook: AppConfig availability', {
      'AppConfig exists': !!AppConfig,
      'AppConfig': AppConfig,
      'AppConfig.proxy': AppConfig?.proxy
    });
    
    // Get app proxy configuration from generated config
    const appProxyPrefix = AppConfig?.proxy?.prefix || "apps";
    const appProxySubpath = AppConfig?.proxy?.subpath || "apps-simplybook";
    
    // Log proxy configuration with fallbacks
    console.log('SimplyBook: App proxy configuration', {
      'AppConfig?.proxy?.prefix': AppConfig?.proxy?.prefix,
      'fallback prefix used': !AppConfig?.proxy?.prefix,
      'final appProxyPrefix': appProxyPrefix,
      'AppConfig?.proxy?.subpath': AppConfig?.proxy?.subpath,
      'fallback subpath used': !AppConfig?.proxy?.subpath,
      'final appProxySubpath': appProxySubpath
    });
    
    const apiUrl = `https://${shopDomain}/${appProxyPrefix}/${appProxySubpath}/api/booking-data?shop=${encodeURIComponent(shopDomain)}`;
    
    // Log the constructed URL
    console.log('SimplyBook: API URL construction', {
      'constructed URL': apiUrl,
      'URL parts': {
        protocol: 'https://',
        shopDomain: shopDomain,
        appProxyPrefix: appProxyPrefix,
        appProxySubpath: appProxySubpath,
        endpoint: '/api/booking-data',
        shopParam: `shop=${encodeURIComponent(shopDomain)}`
      }
    });

    if (AppConfig?.isDevelopment) {
      console.log('SimplyBook: Using development configuration', { appProxyPrefix, appProxySubpath });
    }
    
    console.log('SimplyBook: Making fetch request to:', apiUrl);
    
    const response = await fetch(apiUrl, {
      method: 'GET',
      headers: {
        'Content-Type': 'application/json',
      },
      mode: 'cors'
    });
    
    console.log('SimplyBook: Fetch response received', {
      'response.ok': response.ok,
      'response.status': response.status,
      'response.statusText': response.statusText,
      'response.url': response.url
    });
    
    if (!response.ok) {
      const errorText = await response.text();
      console.error('SimplyBook: Fetch request failed', {
        'attempted URL': apiUrl,
        'response.status': response.status,
        'response.statusText': response.statusText,
        'response.url': response.url,
        'errorText': errorText
      });
      throw new Error(`HTTP error! status: ${response.status} - ${errorText}`);
    }
    
    const data = await response.json();
    
    let processedData;
    if (data.success && data.data) {
      processedData = data.data;
    } else if (data.services && data.staff && data.locations) {
      processedData = data;
    } else if (data.success === false) {
      throw new Error(data.error || 'Failed to load booking data');
    } else {
      throw new Error('Invalid response format from booking API');
    }
    
    if (!processedData.services || !processedData.staff || !processedData.locations) {
      throw new Error('Invalid booking data: missing required fields');
    }
    
    if (processedData.locations && Array.isArray(processedData.locations)) {
      processedData.locations = processedData.locations.filter(location => location.offersServices !== false);
    }
    
    bookingData = processedData;
    // Prefetch common images to reduce first-render jank
    try {
      if (Array.isArray(bookingData.staff)) {
        bookingData.staff.forEach(function(s){
          var src = s && s.avatar && s.avatar.url;
          if (src) { var img = new Image(); img.src = src; }
        });
      }
      if (Array.isArray(bookingData.services)) {
        bookingData.services.forEach(function(svc){
          // Prefetch product image
          var pimg = svc && svc.image && svc.image.url;
          if (pimg) { var pimgEl = new Image(); pimgEl.src = pimg; }
          
          if (Array.isArray(svc.variants)) {
            svc.variants.forEach(function(v){
              var vsrc = v && v.image && v.image.url;
              if (vsrc) { var vimg = new Image(); vimg.src = vsrc; }
            });
          }
        });
      }
    } catch (_) {}
    
    // Theme customization is now handled by Liquid template
    
    // Debug: Log existing bookings
    // Load existing bookings for conflict checking
    
  } catch (error) {
    console.error('SimplyBook: loadBookingData failed', {
      'error.message': error.message,
      'error.name': error.name,
      'error.stack': error.stack,
      'attempted URL': `https://${window.Shopify?.shop?.myshopifyDomain || window.location.hostname}/${AppConfig?.proxy?.prefix || "apps"}/${AppConfig?.proxy?.subpath || "apps-simplybook"}/api/booking-data?shop=${encodeURIComponent(window.Shopify?.shop?.myshopifyDomain || window.location.hostname)}`,
      'AppConfig': AppConfig,
      'window.Shopify': window.Shopify
    });
    throw error;
  }
}

function populateServiceButtons() {
  const container = document.getElementById('service-selection-buttons');
  if (!container || !bookingData || !bookingData.services || !Array.isArray(bookingData.services)) {
    return;
  }
  
  const fragment = document.createDocumentFragment();
  
  bookingData.services.forEach((service) => {
    if (service.variants && service.variants.length > 0) {
      service.variants.forEach((variant) => {
        const button = document.createElement('button');
        button.className = 'simplybook-selection-btn simplybook-service-btn';
        button.onclick = () => selectService(service.id, variant.id);
        
        // Use variant image if available, otherwise fallback to product image
        const variantImage = variant.image && variant.image.url && variant.image.url !== 'null';
        const productImage = service.image && service.image.url && service.image.url !== 'null';
        const hasImage = variantImage || productImage;
        const imageUrl = variantImage ? variant.image.url : (productImage ? service.image.url : null);
        
        const imageHtml = hasImage 
          ? `<img src="${imageUrl}" alt="${service.title} - ${variant.title}" class="simplybook-service-image" onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';"><div class="simplybook-service-image simplybook-service-placeholder" style="display: none;"><div class="simplybook-placeholder-icon">${service.title.charAt(0).toUpperCase()}</div></div>`
          : `<div class="simplybook-service-image simplybook-service-placeholder"><div class="simplybook-placeholder-icon">${service.title.charAt(0).toUpperCase()}</div></div>`;
        
        const durationText = variant.duration ? `${variant.duration} minutes` : '';
        const priceHtml = variant.price ? `<div class="simplybook-selection-price">$${variant.price}</div>` : '';
        
        button.innerHTML = `
          ${imageHtml}
          <div class="simplybook-service-info">
            <div class="simplybook-selection-title">${service.title}</div>
            ${durationText ? `<div class="simplybook-selection-subtitle">${durationText}</div>` : ''}
            ${priceHtml}
          </div>
        `;
        
        fragment.appendChild(button);
      });
    }
  });
  
  container.innerHTML = '';
  container.appendChild(fragment);
}

function populateStaffButtons() {
  const container = document.getElementById('staff-selection-buttons');
  if (!container || !bookingData || !bookingData.staff || !Array.isArray(bookingData.staff)) {
    return;
  }
  
  const availableStaff = bookingData.staff.filter(staff => {
    return staff.isActive === true && hasStaffAvailabilityInNext3Months(staff.id, currentSelection.locationId);
  });
  
  // Quick check: hide professional section if only 1 staff has availability
  if (availableStaff.length === 1) {
    container.parentElement.style.display = 'none';
    return;
  }
  
  if (availableStaff.length === 0) {
    container.innerHTML = '<div style="text-align: center; color: #666; padding: 40px;"><p>No professionals are currently available for booking in the next 3 months. Please check back later or contact us directly.</p></div>';
    return;
  }
  
  const fragment = document.createDocumentFragment();
  
  availableStaff.forEach((staff) => {
    const button = document.createElement('button');
    button.className = 'simplybook-selection-btn simplybook-staff-btn';
    button.onclick = () => selectStaff(staff.id);
    
    const avatarHtml = staff.avatar?.url 
      ? `<img src="${staff.avatar.url}" alt="${staff.name}" class="simplybook-staff-avatar">` 
      : `<div class="simplybook-staff-avatar" style="background: #f0f0f0; display: flex; align-items: center; justify-content: center; font-size: 24px; font-weight: bold; color: #666;">${staff.name.charAt(0)}</div>`;
    
    button.innerHTML = `
      ${avatarHtml}
      <div class="simplybook-staff-info">
        <div class="simplybook-selection-title">${staff.name}</div>
        <div class="simplybook-selection-subtitle">${staff.title || 'Staff member'}</div>
      </div>
    `;
    
    fragment.appendChild(button);
  });
  
  container.innerHTML = '';
  container.appendChild(fragment);
}


// Initialize when DOM is loaded
document.addEventListener('DOMContentLoaded', function() {
  if (!window.api && window.BarbershopClient) {
    window.api = new BarbershopClient();
  }
  // Kick off background prefetch so first click is fast
  try {
    if (!bookingDataPromise) {
      bookingDataPromise = loadBookingData().catch(function(){ bookingDataPromise = null; });
    }
  } catch (_) {}
  
  
  window.onclick = function(event) {
    const modal = document.getElementById('simplybook-modal');
    if (event.target === modal) {
      closeBookingModal();
    }
  };
});
